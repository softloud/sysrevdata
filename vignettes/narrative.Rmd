---
title: "narrative"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{narrative}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

options(encoding="latin1")
```

```{r setup, message=FALSE}
# packages used in this toolchain walkthrough
library(sysrevdata)
library(tidyverse)
library(kableExtra)
library(janitor)

# this avoids tidyverse conflicts with the base function filter
conflicted::conflict_prefer("filter", "dplyr")
```


## creating a narrative synthesis table

The objective of a narrative synthesis is to summarise each study considered in the systematic review in an easy to read table:


**Rows** | One study per row.

**Columns** | Metadata and summarised observations.

As the number of studies increase, and the number of variables considered multiply, this poses a challenge for fitting the table into a succinct readable format. 

Here we consider ways we can condense and format data for presentation for humans to read, as opposed to machine-readable data for analysis and complex visualisation.

We may begin with sparsely-filled wide data or [long-format machine-structured data](complex.html), neither of which are good for publication or interpretation by human readers. So, we will consider how to condense these structures in turn, before demonstrating how to format the output.

## condensing from wide data

We'll use `bufferstrips`, which can be loaded from `sysrevdata`, to investigate this. These data are in a wide and sparse format, useful for creating systematic maps. We'll restrict ourselves to the first 5 studies with `head(5)` as we work through these examples, so this document doesn't run too long. 

```{r}
buffer_example <-
  bufferstrips %>% 
  head(5)
```

```{r include=FALSE, eval=FALSE}
usethis::use_data(buffer_example)
```


To see how these data are sparse and wide, we will extract the abbreviated title, year, and the columns that contain observations relating to spatial scale. 

```{r}
buffer_example %>% 
  select(short_title, contains("spatial"))
```

When we format these data (which we'll provide toolchains for at the end), the wideness becomes an issue. And this is with only the spatial variables (columns) selected. The table is unwieldy, large, and filled with white space. 

```{r echo=FALSE}
buffer_example %>%
  mutate(across(everything(), replace_na, "")) %>%
  select(short_title, contains("spatial")) %>%
  kable() 
```

To solve the wideness issue, we'll condense the variables. Here's a way of doing this for the spatial variable. 

```{r}
buffer_example %>%
  # choose the desired columns
  select(short_title, contains("spatialscale")) %>%
  # condense variable
  unite(# name condensed column
    col = "spatialscale",
    # columns to condense
    contains("spatialscale"),
    # set separator
    sep = "; ",
    # remove NAs
    na.rm = TRUE)

```

But, of course, we wish to do this for all of the variables. The table contains columns that don't need condensing, such as title, year, and so forth. 

```{r}
buffer_example %>% 
  names() %>% cat()
```



Our first task is to identify the columns that have common prefixes, that is, columns that share a common first string. 


```{r}
(
  buffer_variables <-
    # extract the prefix of each column
    # i.e., the string before the first _
    buffer_example %>%
    # we can exclude the column names that don't contain _
    select(contains("_"), -study_country, -study_location) %>%
    # get column names
    names() %>%
    # extract the word before the first _
    str_extract("[a-z]*") %>% {
      # convert to a tibble so we can use count
      tibble(variables = .)
    } %>%
    # count how many instances
    count(variables) %>%
    # filter out the unique variables we won't condense
    filter(n > 1) %>%
    # convert to a vector
    pull(variables)
)

```

```{r include=FALSE, eval=FALSE}
usethis::use_data(buffer_variables, overwrite = TRUE)
```


Now we adapt the code we used to condense the variables to a function.

```{r}
condense_variable <-
function(variable_to_condense, df) {
  buffer_example %>%
    # choose the desired columns
    select(contains(variable_to_condense)) %>%
    # condense variable
    unite(# name condensed column
      col = !!variable_to_condense,
      # columns to condense
      contains(variable_to_condense),
      # set separator
      sep = "; ",
      # remove NAs
      na.rm = TRUE)
}

condense_variable("spatialscale")
  
```

Next we apply our function to every variable we wish to condense and combine the results into a new table of condensed variables.

```{r message=FALSE}

condensed_buffer_example <-
buffer_variables %>%
  # apply the function to each variable we wish to condense, producing a list of dataframes
  map(condense_variable) %>% 
  # bind the columns together, with the short title as the first column
  bind_cols(
    buffer_example %>% select(-contains(buffer_variables)), .
  )

# just showing the condensed variables
condensed_buffer_example %>% 
  select(short_title, contains(buffer_variables))

```

```{r include=FALSE, eval=FALSE}
usethis::use_data(condensed_buffer_example, overwrite=TRUE)
```


## condensing from long data

Suppose we start with long-format data, in a tidy format, where each row is a category and subcategory observation for a specific study. In the interests of space, we'll show the title, category, and subcategory, the columns that don't require condensing remain the same. 

For this section, we'll pretend the `bufferstrips` dataset is long, using this dataframe, created in the [vignette](complex.html) on creating long-form datasets.

```{r}
buffer_example_long %>% 
  # in the interests of space, we'll just show the relevant columns
  select(short_title, category, subcategory)


```


Now we'll pivot wide so we can condense. 

```{r}
# this function creates a string from the vector of multiple values
# NB: it's entirely possible there's a way to do this using pivot_wider, but I haven't found it
mash_subcategories <- function(x) {
  paste0(x, collapse = "; ")
}

# go from long to wide
buffer_example_long %>% 
  pivot_wider(
    names_from = category,
    values_from = subcategory,
    values_fn = mash_subcategories
  ) %>% 
  # we'll just show a few examples because space
  select(short_title, vegetated_strip_description, farmingproductionsystem)

```

Now we have the long data in the same condensed format as the wide data in the section above, and we are ready to consider formatting functions for publication.

## formatting for output

```{r}
condensed_buffer_example %>% 
  # converts dataframe to an html output table
  kable() %>% 
  # useful function for customising table formatting
  kable_styling(
    bootstrap_options = "striped", 
    font_size = 9)

```

We can present this with a separate table of metadata, using the short title as the reference. We'll combine the googlescholar link with the title.

```{r}
study_descriptions <-
buffer_example %>% 
  # combine the google scholar link in a way that will be rendered as a clickable link 
  mutate(title = str_c("[", title, "](",google_scholar_link,")")) %>% 
  select(-contains(buffer_variables),
         -google_scholar_link) 

study_descriptions %>% 
  kable() %>% 
  kable_styling("striped",
                font_size = 9)


```

And, if we are happy to have a wider table, we can combine both tables together to form one narrative synthesis table with all variables condensed. Although wide, it is not as wide or sparse as where we started, and is much easier to read.

```{r}
full_join(study_descriptions, condensed_buffer_example,
          by = "short_title") %>% 
  kable() %>% 
   kable_styling("striped",
                font_size = 9)

```

