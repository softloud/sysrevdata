---
title: "walkthroughs"
output: 
  distill::distill_article:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# packages used in this walkthrough
library(tidyverse) # all purpose cleaner
library(janitor) # clean_names for snake_case
library(skimr) # skim to summarise data
library(conflicted)
conflict_prefer("filter", "dplyr")
library(kableExtra)

# the tidyverse is a metapackage that loads a suite of tools
# useful for working with and summarising data
```
<aside>
If not already installed, run `install.packages("package name")` in the console before beginning.
</aside>

# Get data

> todo: set up package & embed website

```{r}
example_dat <- 
  read_csv("data-raw/Haddawayetal2018bufferstrips.csv",
           col_types = paste(rep("c",84), collapse = ""),
            locale = locale(encoding="UTF-8")
           ) %>% 
  # clean variables names to snake_case
  clean_names()


```

# Check assumptions about data

Inspecting large datasets can slow your machine down, so best to check dimensions before beginning to work with data. 

```{r}
example_dat %>%
   dim()

```

With `r example_dat %>% dim() %>% pluck(1)` rows and `r example_dat %>% dim() %>% pluck(2)` columns, this is not so big that we can't inspect it. 

```{r eval=FALSE}
# inspect data 
example_dat %>% 
  View()

```

We can also use summary tools, such as `skimr::skim`.

> todo footnote about nomenclature

Running the following command in the console, we note a number of variables with only one unique (`n_unique`). 

```{r eval=FALSE}
skim(example_dat)

```

Since the `skimr::skim` summary table is a dataframe, we can identify what these variables are.

```{r}
example_dat %>% 
  # summarise
  skim() %>%
  # extract variables with only one unique character string in the column
  filter(character.n_unique == 1) %>% 
  # output name of variable from skim
  pluck("skim_variable") 

```

We can see a pattern of groupings by prefix. Now we inspect one variable: the data prefixed with `studydesign`. 

# Wide to narrative (condensed)

To produce a narrative table, we combine wide columns into one concatenated, think placing text side by side, variable. In conventional spreadsheet software, this is combining cells.  

## Condensing one variable

```{r}
# take a look at the study design columns
example_dat %>% 
  select(contains("studydesign"))

```

We see at least the top of the data is split with one indication in `studydesign_observational`

First, we check our assumption that there are never strings in both columns.

```{r}

# check assumption that variable is encoded across
# two columns
example_dat %>% 
  select(contains("studydesign")) %>% 
  filter(
    !( # which rows do not meet these assumptions
      
      # na in observational and manipulative string
      (is.na(studydesign_observational) & 
        studydesign_manipulative == "Manipulative") | # or
        
        # na in manipulative & observational sring
        (is.na(studydesign_manipulative) & studydesign_observational == "Observational")
    )
  )

```

The data are not _quite_ as expected. There are three levels to a condensed `studydesign` variable: observational, manipulative, and _both_ observational and manipulative.

Since we know the structure of all the data now, one way to condense these two columns would be via concatenating the variables.

```{r}
study_design <- 
  example_dat %>%
  # for this example
  select(contains("studydesign")) %>% 
  unite(
    col = "study_design",
    contains("studydesign"),
    sep = "; ",
    na.rm = TRUE
  ) 

# top of studydesign
study_design

# check the two-value columns
study_design %>% 
  filter(str_length(study_design) > str_length("Observational"))

```

## Condensing all wide variables

```{r}
condense_readable <-
  function(dat, variable) {
    unite(dat, col = {{variable}}, contains({{variable}}), na.rm = TRUE, sep = "; ")
  }

```

```{r}
# condense all

example_narrative <- 
  example_dat %>% 
  condense_readable("studydesign") %>% 
  condense_readable("spatialscale") %>% 
  condense_readable("measurement") %>% 
  condense_readable("farmingsystem") %>% 
  condense_readable("farmingproductionsystem") %>% 
  condense_readable("vegetationtype") %>% 
  condense_readable("striplocation") %>% 
  condense_readable("stripmanagement") 

# take a look at our condensed variables
example_narrative %>%
  select(
    studydesign,
    spatialscale,
    measurement,
    farmingsystem,
    farmingproductionsystem,
    vegetationtype,
    striplocation,
    stripmanagement
  )

```

# Narrative to long

Now, if we begin with a narrative table, we may wish to extract specific variables.

Consider, again, `studydesign`. 

```{r}

studydesign_long <-
  example_narrative %>% 
  unnest(studydesign=strsplit(studydesign, "; "))

```

For the records that have more than one entry for `studydesign`, 

```{r}
example_narrative %>% count(studydesign)

studydesign_long %>% dim()

studydesign_long %>% 
  count(studydesign)

```

As with condensing, we can achieve the converse, by iterating this code through each condensed variable. We'll replace `Not described` with `NA`, so that we don't add new rows for these indications of no observation. 

```{r}




```


```{r}

example_long <-
  example_narrative %>% 
  mutate(
  studydesign = strsplit(studydesign, "; "),
  spatialscale = strsplit(spatialscale, "; "),
  measurement = strsplit(measurement, "; "),
  farmingsystem = strsplit(farmingsystem, "; "),
  farmingproductionsystem = strsplit(farmingproductionsystem, "; "),
  vegetationtype = strsplit(vegetationtype, "; "),
  striplocation = strsplit(striplocation, "; "),
  stripmanagement = strsplit(stripmanagement, "; ")
  ) %>% 
  unnest(c(studydesign, spatialscale, measurement, farmingsystem, farmingproductionsystem, vegetationtype, striplocation, stripmanagement))



```


```{r}
example_long %>% 
  head() %>% 
  select(short_title, year, studydesign, spatialscale, measurement)
  kable()


```

> Should we replacee "not described" with NA?

Note that despite the plotting etc. advantages of long, it can generate a much larger dataset very quickly. This makes it harder to visuallly inspect the data.

```{r}

# dimensions of data we started with
example_dat %>% dim()

# dimensions of long data
example_long %>% dim()



```


# Long to narrative

```{r}



```



# Narrative to wide

Suppose, that we begin with condensed data, and wish to structure it wide, for w

> Identify what the wide dataset is used for in this context

# Wide to long

# Long to wide

If we begin with long data, we may wish to convert it to wide for 

> --? for what? Discuss with Matt.

```{r}
example_long %>% 
  pivot_wider(
    values_from = c(studydesign, striplocation)
  )


```


